# Отчет о домашней работе #2
## Функциональность приложения
### Возможность регистрации новых животных
Учет животных описывается доменными объектами `Animal` и `Enclosure`. `Animal` хранит в себе полную информацию о животном. Однако для учета их корректного размещения необходимо так же обращаться к вольерам. 

Классы из слоя Application ответственные за обработку бизнес логики связанной с регистраций клиента нахоядтся в папке Animal. Наиболее содержательный из них `AnimalRegisterService`.

`AnimalRepository` - класс который ответственнен за реализацию механизмов хранения и прямой работы с данными о животных

`AnimalRegisterController` - класс который предоставляет описание запросов к реализованному Web-api и вызывает всю логику которая была реализована ниже. Что бы более точно отображать значения при запросах используется DTO объект `AnimalWithTypeName`. Он сохраняет отдельным полем тип, которые унаследовал объект(Хищник или Травоядное). При работе с этим контроллером можно: просматривать, добавлять, удалять записи о животных из репозитория, а так же переносить животное из одного вольера в другой.
### Возможность регистрации вольеров
Работа с вольерами велась из аналогичных принципов. Класс `Enclosure` ответственнен за описание модели вольера.

`EnclosureRegisterService` - класс который инкапсулирует бизнес-логику по созданию удалению и настройке вольеров.

`EnclosureRepository` - содержит в себе in-memory реализацию слоя хранения данных(объектов `Enclosure`), а так же их изменению без предварительных проверок на соответствие бизнес-логике
`EnclosureRegisterController` - предоставляет доступ к части Web-api которая ответственная за обработку запросов менеджмента вольеров
### Другие действия связанные с животными
Так же помимо базовой регистрации, животных можно кормить(выполнять задачи по кормлению) и перемещать между вольерами. Для того что бы описать эти методы используются следующие классы, находящиеся на слое Application:
`AnimalHealthMonitoringService` и `AnimalFeedingService`. Они работают с такой же доменной моделью животного(которая надо сказать, включает в себя несколько `VO`-объектов) и обращаются к тому же репозиторию

Отличия возникают в слое представлений: `AnimalFeedController` и `AnimalHealthController` являются контроллерами действий связанных с этими сервисами. Первый позволяет помимо взаимодействия с животными, создавать и удалять события кормления, а так же просматривать список с полными данными о них. Второй менять значения состояния здоровья животного, просмотр изменений осуществляется при помощи контроллера `AnimalRegisterController`.

Классы `Feeding`, `FeedingRepository` поддерживают `AnimalFeedController` предоставляя соответственно описание доменной модели кормления, а так же репозитория в котором хранятся кормления

### Генерация отчетов и сбор статистики о работе зоопарка
Сбор статистики разделен на событийно обрабатываемую и несобытийно обрабатываемую. Для обработки первой(и учета данных о пермещениях и кормлениях животных) были созданы следующие классы событий:
* `AnimalFedEvent` - запсукается если животное было накоромлено
* `AnimalMovedEvent`- запускается если животное было успешно перемещено из одного вольера в другой
* `NewDayStartedEvent` - запускается если наступил новый день, и нужно обновить все записи о сделанных кормлениях

Все они наследуют интерфейсу `IDomainEvent` который используется в других классах для обозначения доменных событий. `DomainEventService` предоставляет обертку, для запуска события, а так же для подписки методов на него.

Подписчиком выступает метод класса `ZooReporterService`, который настраивается с помощью специального сервиса(запускаемого фоновым процессом перед стартом работы) - `ZooReporterInitService`. Сам же изначальный сервис предоставляет как метод обработки событий поступивших к нему, так и методы возвращающие доступную все время информацию, те полностью предоставляет статистику.

`ReportSaverService` - сервис который обрабатывает информацию прешедую из событий и сохраняет ее в виде .csv файла на диск

`ReportRepository` - репозиторий, который обрабатывет поступившую к нему информацию от событий и сохраняет ее в виде строчки таблицы, приводя к единому формату. Несмотря на то что работает только с информацией из событий - сам по себе не имеет подписанных на события методов.

`ZooStatisticsController` - контроллер который предоставляет в качестве api все методы(те как использующие события и сохраняющие отчет в виде файла, так и обычные). Здесь описываются реакции на запрос пользователя о:
Какие были совершены перемещения или кормления животных? Какие вольеры свободны в зоопарке? и тд

## Принципы использованные в разработке данного проекта 
### Принципы DDD
Все объекты в доменной области которые имеют уникальный `Guid` - сущности и могут быть изменены. Остальные объекты являются `Value Objects` и могут быть только пересозданы. Объекты `Value Objects` композированы внутри сущностей, поэтому сущности представляют из себя агреграты таких объектов и обычных переменных(например `Animal` или `Enclosure`).

Сами экземпляры доменных классов, при этом, хранятся в репозиториях - классах которые реализуют для внешних слоев методы доступа для поиска, изменения и тд, скрывая работу с массивами данных от бизнес логики.

Сервисы были разделены на прикладные(как например те, которые работают с событиями) и доменные - инкапсулирующие бизнес-логику(например учет животных).

Для создания сложных доменных объектов используются фабрики, с целью перераспределеить ответственность за неправильный конструктор объекта и создать гибкость в создании новых экземпляров

События домена облегчают взаимодействия между двумя слабо-связанными сервисами или доменными моделями.

### Принципы Clean Architechture
Согласно чистой архитектуре, все предыдущие объекты не должны находиться вместе, а быть разделенными на несколько слоев:
* Domain - слой в котором хранятся, доменные объекты и сущности
* Application - слой в котором хранятся сценарии использования приложения - те классы обрабатывающие техническую и бизнес логики
* Infrastructure - слой в котором хранятся классы, ответственные за обработку данных, между пользователем и сценарием использования описанном выше
* Presentation - слой в котором хранятся методы и классы, описывающие взаимодействие пользователя с данными из предыдущего слоя

  Все слои в решении, отмечены своими проектами. Зависимости между слоями в решении направлены "внутрь", те:
  `Presentation --> Application --> Infrastructure --> Domain`
  от наиболее близкого к пользовательским сценарием слоя, до слоя наиболее близкого к изначальной модели данных

  Передача данным, при этом, между слоями происходит посредством интерфейсных ссылок на сервисы и репозитории, что обеспечивает сокрытие лишних методов и данных, и безопасность их использования

  Эти аспекты позволяют легко проводить тестирование как слоев в отдельности так и взаимодействий между ними, а так же заменять отдельные сервисы, фреймворки, решения предназначенные для хранения данных без необходимости переписывать слишком много кода
